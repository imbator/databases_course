# Симулятор ОРИОКСа
## Для курса "Базы данных"

Привет! Этот небольшой гайд создан для того, чтобы разобраться в работе Qt-аналога ориокса, созданного в учебных целях для данного курса.

# Содержание

1. [Введение](#введение)
2. [Общие сведения](#основная-часть)
    1. [Взаимодействие с SQL](#sql)
        * [Подключение к серверу PostgreSQL](#sql)
        * [SQLQuery](#query)
    2. [Таблицы, таблицы и еще раз таблицы](#frotend)
    3. [Базовые структуры](#structs)
3. [Возможности пользователя](#software)
    1. [Форма логина](#loginform)
    2. [Студент](#student)
    3. [Преподаватель](#teacher)
    4. [Методист](#methodist)
4. [FAQ](#other)


## Введение
ОРИОКС является отличным примером для демонстрации того, как базы данных в разработке любого продукта. 
Данное программное обеспечение было написано при помощи фреймворка Qt, с которым Вы уже работали раннее. Архитектура приложения выстраивалась с использованием объектно-ориентированного подхода (ООП).

## Общие сведения

### Взаимодействие с SQL

#### Подключение к серверу PostgreSQL

Для того чтобы работать с PostgreSQL из под Qt, я использовал библиотеку psql. Подробно о том, как подготовить Qt Creator к работе с ней, Вы можете ознакомиться в тексте лабораторного практикума.


Прежде всего, рассмотрим, как реализован "мост" между сервером PostgreSQL и Qt. Реализация описана в файлах **sqlservice.h** и **sqlservice.cpp**. Для того чтобы была возможность работать с базой данных, подключается следующий заголовочный файл:

```cpp
#include <QSqlDatabase>
```

Подключение к серверу PostgreSQL и, соответственно, к базе данных, производится в теле данной функции:

```cpp
void databaseConnect(); // Функция подключения к базе данных
```

Внутри данной функции производится инициализация объекта с именем *db* типа *QSqlDatabase*:

```cpp
 db = QSqlDatabase::addDatabase("QPSQL"); // Инициализирую базу данных при помощи "QPSQL"
```

 Через данный объект и будет производиться установка соединения с базой данных на сервере. 

 Далее у данного обьекта производится установка параметров подключения через методы *setHostName*, *setDatabaseName*, после чего при помощи метода *open()*
 производится попытка установить соединение. Данный метод имеет тип bool и возвращает true или false. Именно этим фактом я воспользовался, для того чтобы проверить, установилось ли соединение с БД:

 ```cpp
 if (!db.open()) {
        qDebug() << "Failed to connect to database.";
        qDebug() << "Error: ";
        qDebug() << db.lastError().text();
    } else {
        qDebug() << "Connected to database succesfully!";
    }
 ```

#### SQLQuery

Работа с SQL, конечно же, подразумевает выполнение SQL-запросов. Давайте разберемся, как такая возможность реализована в данном программном обеспечении. Следующий заголовочный файл является частью библиотеки psql и позволяет выполнять SQL-запросы:

```cpp
#include <QSqlQuery> // query (от англ.) - очередь, запрос
```
В файле 'sqlservice.h' объявлена функция *runQuery*, внутри которой описан пример логики выполнения SQL- запроса. Ниже приведен ее код с комментариями, подробно описывающими суть происходящего:

```cpp
QSqlQuery SqlService::runQuery(QString content) {
    
    // Пример выполнения SQL-запроса
    
    QSqlQuery query; 
    
    // Обьект класса QSqlQuery позволяет выполнять SQL-запросы,
    // хранит в себе "таблицу", полученную после sql-запроса
    
    query.exec(content); // Метод exec() принимает на вход текст запроса

    // Обработка запроса

    if (query.lastError().isValid()) {
        qDebug() << "Ошибка выполнения запроса:" << query.lastError().text();
    } else {
        // Запрос выполнен успешно
    }
    return query; // Возвращает 
}
```
Замечу, что конкретно данная функция в ходе работы приложения использоваться не будет и приведена лишь в ознакомительных целях. Однако, концепция выполнения запроса будет именно такая. О том, как именно будут выполняться запросы и как будет производиться *обработка* результата запроса будет расказано далее.







### Frontend-часть приложения
### Базовые структуры

## Функционал приложения

### Форма логина
### Студент
### Преподаватель
### Методист

## FAQ


